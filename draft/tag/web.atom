<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://preaction.me/draft/tag/web/</id>
    <title>preaction</title>
    <updated>2017-12-17T00:00:00Z</updated>
    <link href="http://preaction.me/draft/tag/web.atom" rel="self" />
    <link href="http://preaction.me/draft/tag/web/" rel="alternate" />
    <generator version="0.085">Statocles</generator>
    <entry>
        <id>http://preaction.me/draft/2017/12/17/yancy-starts-a-conversation/</id>
        <title>Yancy Starts a Conversation</title>
        <link href="http://preaction.me/draft/2017/12/17/yancy-starts-a-conversation/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>Continuing on from [our last post which created a simple blog app].
A blog without comments is just a website. So, let&#39;s add a way for users
to interact with our content.</p>

<p>First, as before, we need a database table. A comment on our blog will
need an ID, the date/time it was created, the author&#39;s name and e-mail
address, and the content of their comment. We will also need to store
the ID of the blog post the user is commenting on.</p>

<p>We add the SQL that builds this table as a new migration. When our app
starts up, <a href="http://metacpan.org/pod/Mojo::Pg">Mojo::Pg</a> will look to see
what version of the database schema we have. If necessary, it will
upgrade our database by running the migration SQL snippet.</p>

<pre><code>@@ migrations
-- 1 up
CREATE TABLE blog (
    id SERIAL PRIMARY KEY,
    title VARCHAR NOT NULL,
    created TIMESTAMP NOT NULL DEFAULT NOW(),
    markdown TEXT NOT NULL,
    html TEXT NOT NULL
);
-- 1 down
DROP TABLE blog;
-- 2 up
CREATE TABLE blog_comment (
    id SERIAL PRIMARY KEY,
    blog_id INTEGER REFERENCES blog ON DELETE CASCADE,
    author_name VARCHAR NOT NULL,
    author_email VARCHAR NOT NULL,
    content TEXT NOT NULL
);
-- 2 down
DROP TABLE blog_comment;
</code></pre>

<p>Now that we have a place to store them, we should tell Yancy about our
new collection so we can manage it. This won&#39;t be the way that users add
comments to our site, but it will be the way we edit and delete comments
from our site.</p>

<pre><code>use Mojolicious::Lite;
plugin Yancy =&gt; {
    backend =&gt; &#39;pg://localhost/blog&#39;,
    collections =&gt; {
        blog_comment =&gt; {
            &#39;x-list-columns&#39; =&gt; [qw( id blog_id author_name author_email )],
            required =&gt; [qw( author_name author_email content )],
            properties =&gt; {
                id =&gt; { type =&gt; &#39;integer&#39;, readOnly =&gt; 1 },
                blog_id =&gt; { type =&gt; &#39;integer&#39; },
                author_name =&gt; { type =&gt; &#39;string&#39; },
                author_email =&gt; { type =&gt; &#39;string&#39; },
                content =&gt; { type =&gt; &#39;string&#39; },
            },
        },
    },
};
</code></pre>

<p>With our <code>blog_comment</code> collection, we&#39;re also using the
<code>x-list-columns</code> value to set which columns are shown in Yancy&#39;s list
view. This way we can easily see the author information while we&#39;re
perusing the list.</p>

<p>Next, we need a way for users to add new comments to a blog post. For
this, we&#39;ll need a form, and a route that accepts the form contents and
adds the comment to the database.</p>

<p>First, the route. The route will accept three form parameters:
<code>author_name</code>, <code>author_email</code>, and <code>content</code>. Then we need to set the
correct <code>blog_id</code>. With the data ready, we can use <a href="https://metacpan.org/pod/Mojolicious::Plugin::Yancy#yancy.create">the <code>yancy.create</code>
helper</a>
to write the new comment. This helper will validate our data according
to our configuration and throw an exception if it&#39;s invalid.  Finally,
we can redirect the user back to the front page of the blog.</p>

<pre><code>post &#39;/blog/:id/comment&#39; =&gt; sub {
    my ( $c ) = @_;
    # Create the new comment
    my %item;
    for my $field (qw( author_name author_email content )) {
        $item{ $field } = $c-&gt;param( $field );
    }
    $item{ blog_id } = $c-&gt;stash( &#39;id&#39; );
    eval { $c-&gt;yancy-&gt;create( blog_comment =&gt; \%item ) };
    if ( $@ ) {
        return $c-&gt;render(
            status =&gt; 400,
            text =&gt; &quot;Error adding comment: $@&quot;,
        );
    }
    # Back to the blog
    $c-&gt;res-&gt;headers-&gt;location( &#39;/&#39; );
    return $c-&gt;rendered( status =&gt; 302 );
};
</code></pre>

<p>Now we need a form. We&#39;ll use Bootstrap to make it look nice.</p>

<pre><code>% for my $post ( @{ stash &#39;posts&#39; } ) {
    &lt;%== $post-&gt;{html} %&gt;
    &lt;h2&gt;Comments&lt;/h2&gt;
    &lt;form class=&quot;form&quot; method=&quot;post&quot; action=&quot;/blog/&lt;%= $post-&gt;{id} %&gt;/comment&quot;&gt;
        &lt;div class=&quot;form-group row&quot;&gt;
            &lt;label class=&quot;col-form-label col-2&quot;&gt;Name&lt;/label&gt;
            &lt;input name=&quot;author_name&quot; class=&quot;form-control col-4&quot; /&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group row&quot;&gt;
            &lt;label class=&quot;col-form-label col-2&quot;&gt;E-mail&lt;/label&gt;
            &lt;input name=&quot;author_email&quot; class=&quot;form-control col-4&quot; /&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group row&quot;&gt;
            &lt;label class=&quot;col-form-label col-2&quot;&gt;Comment&lt;/label&gt;
            &lt;textarea name=&quot;content&quot; rows=&quot;6&quot; class=&quot;form-control col-4&quot;&gt;&lt;/textarea&gt;
        &lt;/div&gt;
        &lt;button class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
% }
</code></pre>

<p><img alt="Screenshot showing the comment form on the blog page" src="http://preaction.me/draft/2017/12/17/yancy-starts-a-conversation/comment-form.png"></p>

<p>Finally, we need to display the comments with our posts. We will have to
rewrite our main <code>/</code> route to add the comments to the post data, like
so:</p>

<pre><code>get &#39;/&#39; =&gt; sub {
    my ( $c ) = @_;
    # Get posts, latest post first
    my @posts = $c-&gt;yancy-&gt;list(
        blog =&gt; {},
        { order_by =&gt; { -desc =&gt; &#39;created&#39; } },
    );
    for my $post ( @posts ) {
        # Add comments to the post, latest comment first
        $post-&gt;{comments} = [
            $c-&gt;yancy-&gt;list(
                blog_comment =&gt; { blog_id =&gt; $post-&gt;{id} },
                { order_by =&gt; { -desc =&gt; &#39;created&#39; } },
            )
        ];
    }
    return $c-&gt;render( &#39;index&#39;, posts =&gt; \@posts );
};
</code></pre>

<p>And then we can display our posts in our template:</p>

<pre><code>% for my $comment ( @{ $post-&gt;{comments} } ) {
    &lt;h3&gt;
        &lt;%= $comment-&gt;{author_name} %&gt;
    &lt;/h3&gt;
    &lt;date&gt;&lt;%= $comment-&gt;{created} %&gt;&lt;/date&gt;
    &lt;p style=&quot;white-space: pre-line&quot;&gt;&lt;%= $comment-&gt;{content} %&gt;&lt;/p&gt;
% }
</code></pre>

<p><img alt="Screenshot showing comment form and posted comment" src="http://preaction.me/draft/2017/12/17/yancy-starts-a-conversation/blog-comments.png"></p>

<p>Once we have some comments, we can manage them using Yancy.</p>

<p><img alt="Screenshot showing list of comments in Yancy" src="http://preaction.me/draft/2017/12/17/yancy-starts-a-conversation/manage-comments.png"></p>

<p><a href="http://preaction.me/draft/2017/12/17/yancy-starts-a-conversation/04-template.pl">Here&#39;s the whole code for our blog with comments</a>.
Mojolicious and makes it easy to build a content-based website, and
Yancy makes it easy to manage.</p>

                <p><a href="http://preaction.me/draft/2017/12/17/yancy-starts-a-conversation/#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="http://preaction.me/draft/tag/yancy/">yancy</a>
                <a href="http://preaction.me/draft/tag/perl/">perl</a>
                <a href="http://preaction.me/draft/tag/web/">web</a>
                <a href="http://preaction.me/draft/tag/mojolicious/">mojolicious</a>
            </p>
        ]]></content>
        <updated>2017-12-17T00:00:00Z</updated>
        <category term="yancy" />
        <category term="perl" />
        <category term="web" />
        <category term="mojolicious" />
    </entry>
    <entry>
        <id>http://preaction.me/draft/2017/12/10/start-a-new-yancy-app/</id>
        <title>Start a New Yancy App</title>
        <link href="http://preaction.me/draft/2017/12/10/start-a-new-yancy-app/" rel="alternate" />
        <content type="html"><![CDATA[
            <p><a href="http://metacpan.org/pod/Yancy">Yancy</a> is a new content management
plugin for the <a href="http://mojolicious.org">Mojolicious web framework</a>.
Yancy allows you to easily administrate your site’s content just by
describing it using <a href="http://json-schema.org">JSON Schema</a>. Yancy
supports <a href="http://metacpan.org/pod/Yancy::Backend">multiple backends</a>, so
your site&#39;s content can be in
<a href="http://metacpan.org/pod/Yancy::Backend::Pg">Postgres</a>,
<a href="http://metacpan.org/pod/Yancy::Backend::Mysql">MySQL</a>, and
<a href="http://metacpan.org/pod/Yancy::Backend::Dbic">DBIx::Class</a>.</p>

<p>For an demonstration application, let’s create a simple blog using
<a href="http://mojolicious.org/perldoc/Mojolicious/Lite">Mojolicious::Lite</a>.
First we need to create a database schema for our blog posts. Let&#39;s use
<a href="http://metacpan.org/pod/Mojo::Pg">Mojo::Pg</a> and its <a href="http://metacpan.org/pod/Mojo::Pg::Migrations">migrations
feature</a> to create a table
called &quot;blog&quot; with fields for an ID, a title, a date, some markdown, and
some HTML.</p>

<pre><code class="hljs"><span class="hljs-comment"># myapp.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
<span class="hljs-keyword">use</span> <span class="hljs-function">Mojo::Pg</span>;

<span class="hljs-keyword">my</span> <span class="hljs-type">$pg</span> = <span class="hljs-function">Mojo::Pg</span>-&gt;new( &#39;<span class="hljs-string">postgres://localhost/blog</span>&#39; );
<span class="hljs-type">$pg</span>-&gt;<span class="hljs-type">migrations</span>-&gt;<span class="hljs-type">from_data</span>-&gt;<span class="hljs-type">migrate</span>;

<span class="hljs-keyword">__DATA__</span>
@@ migrations
-- 1 up
CREATE TABLE blog (
    id SERIAL PRIMARY KEY,
    title VARCHAR NOT NULL,
    created TIMESTAMP NOT NULL DEFAULT NOW(),
    markdown TEXT NOT NULL,
    html TEXT NOT NULL
);
-- 1 down
DROP TABLE blog;
</code></pre>

<p>Next we add <a href="http://metacpan.org/pod/Mojolicious::Plugin::Yancy">the Yancy
plugin</a> and tell it
about our backend and data. Yancy deals with data as a set of
collections which contain items. For a relational database like
Postgres, a collection is a table, and an item is a row in that table.</p>

<p>Yancy uses a JSON schema to describe each item in a collection.
For our <code>blog</code> collection, we have five fields:</p>

<ol>
<li><code>id</code> which is an auto-generated integer and should be read-only</li>
<li><code>title</code> which is a free-form string which is required</li>
<li><code>created</code> which is an ISO8601 date/time string, auto-generated</li>
<li><code>markdown</code> which is a required Markdown-formatted string</li>
<li><code>html</code>, a string which holds the rendered Markdown and is also required</li>
</ol>

<p>Here&#39;s our configured Yancy <code>blog</code> collection:</p>

<pre><code class="hljs">plugin Yancy =&gt; {
    backend =&gt; &#39;<span class="hljs-string">pg://localhost/blog</span>&#39;,
    collections =&gt; {
        blog =&gt; {
            required =&gt; [ &#39;<span class="hljs-string">title</span>&#39;, &#39;<span class="hljs-string">markdown</span>&#39;, &#39;<span class="hljs-string">html</span>&#39; ],
            properties =&gt; {
                id =&gt; {
                    type =&gt; &#39;<span class="hljs-string">integer</span>&#39;,
                    readOnly =&gt; <span class="hljs-number">1</span>,
                },
                title =&gt; {
                    type =&gt; &#39;<span class="hljs-string">string</span>&#39;,
                },
                created =&gt; {
                    type =&gt; &#39;<span class="hljs-string">string</span>&#39;,
                    <span class="hljs-function">format</span> =&gt; &#39;<span class="hljs-string">date-time</span>&#39;,
                    readOnly =&gt; <span class="hljs-number">1</span>,
                },
                markdown =&gt; {
                    type =&gt; &#39;<span class="hljs-string">string</span>&#39;,
                    <span class="hljs-function">format</span> =&gt; &#39;<span class="hljs-string">markdown</span>&#39;,
                    &#39;<span class="hljs-string">x-html-field</span>&#39; =&gt; &#39;<span class="hljs-string">html</span>&#39;,
                },
                html =&gt; {
                    type =&gt; &#39;<span class="hljs-string">string</span>&#39;,
                },
            },
        },
    },
};
</code></pre>

<p>Yancy will build us a rich form for our collection from the field types
we tell it. Some fields, like the <code>markdown</code> field, take additional
configuration: <code>x-html-field</code> tells the Markdown field where to save the
rendered HTML. There&#39;s plenty of customization options in <a href="http://metacpan.org/pod/Yancy#CONFIGURATION">the Yancy
configuration documentation</a>.</p>

<p>Now we can start up our app and go to <a href="http://127.0.0.1:3000/yancy">http://127.0.0.1:3000/yancy</a> to
manage our site&#39;s content:</p>

<pre><code>$ perl myapp.pl daemon
Server available at http://127.0.0.1:3000
</code></pre>

<p><img alt="Screen shot of adding a new blog item with Yancy" src="http://preaction.me/draft/2017/12/10/start-a-new-yancy-app/adding-item.png">
<img alt="Screen shot of Yancy after the new blog item is added" src="http://preaction.me/draft/2017/12/10/start-a-new-yancy-app/item-added.png"></p>

<p>Finally, we need some way to display our blog posts.  <a href="http://metacpan.org/pod/Mojolicious::Plugin::Yancy#HELPERS">Yancy provides
helpers to access our
data</a>. Let&#39;s
use the <code>list</code> helper to display a list of blog posts. This helper takes
a collection name and gives us a list of items in that collection. It
also allows us to search for items and order them to our liking. Since
we&#39;ve got a blog, we will order by the creation date, descending.</p>

<pre><code class="hljs">get &#39;<span class="hljs-string">/</span>&#39; =&gt; <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        &#39;<span class="hljs-string">index</span>&#39;,
        posts =&gt; [ <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">yancy</span>-&gt;<span class="hljs-type">list</span>(
            &#39;<span class="hljs-string">blog</span>&#39;, {}, { order_by =&gt; { -desc =&gt; &#39;<span class="hljs-string">created</span>&#39; } },
        ) ],
    );
};
</code></pre>

<p>Now we just need an HTML template to go with our route! Here, I use the standard
<a href="http://getbootstrap.com/docs/4.0/getting-started/introduction/#starter-template">Bootstrap 4 starter template</a>
and add this short loop to render our blog posts:</p>

<pre><code>&lt;main role=&quot;main&quot; class=&quot;container&quot;&gt;
% for my $post ( @{ stash &#39;posts&#39; } ) {
    &lt;%== $post-&gt;{html} %&gt;
% }
&lt;/main&gt;
</code></pre>

<p><a href="http://preaction.me/draft/2017/12/10/start-a-new-yancy-app/04-template.pl">Now we have our completed application</a> and we can test
to see our blog post:</p>

<pre><code>$ perl myapp.pl daemon
Server available at http://127.0.0.1:3000
</code></pre>

<p><img alt="The rendered blog post with our template" src="http://preaction.me/draft/2017/12/10/start-a-new-yancy-app/blog-post.png"></p>

<p>Yancy provides a rapid way to get started building a Mojolicious
application (above Mojolicious’s already rapid development). Yancy
provides a basic level of content management so site developers can
focus on what makes their site unique.</p>

                <p><a href="http://preaction.me/draft/2017/12/10/start-a-new-yancy-app/#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="http://preaction.me/draft/tag/mojolicious/">mojolicious</a>
                <a href="http://preaction.me/draft/tag/web/">web</a>
            </p>
        ]]></content>
        <updated>2017-12-10T00:00:00Z</updated>
        <category term="mojolicious" />
        <category term="web" />
    </entry>
    <entry>
        <id>http://preaction.me/draft/2017/12/04/mocking-a-rest-api-with-mojolicious/</id>
        <title>Mocking a REST API</title>
        <link href="http://preaction.me/draft/2017/12/04/mocking-a-rest-api-with-mojolicious/" rel="alternate" />
        <content type="html"><![CDATA[
            <p>One of my applications is a pure-JavaScript UI for a JSON API. This UI
is an entirely different project that communicates with a public API
using an OpenAPI specification.</p>

<p>Our public API is huge and complex: To set up the public API, I need
a database, sample data, and three other private API servers that
perform individual tasks as directed by the public API. Worse, I would
need to set up a lot of different test scenarios with different kinds of
data.</p>

<p>It would be a lot easier to set up a mock public API that I could use to
test my UI, and it turns out that Mojolicious makes this very easy.</p>

<p>So let&#39;s set up a simple Mojolicious::Lite app that responds to a path
with a JSON response:</p>

<pre><code class="hljs"><span class="hljs-comment"># test-api.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
get &#39;<span class="hljs-string">/servers</span>&#39; =&gt; <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        json =&gt; [
            { ip =&gt; &#39;<span class="hljs-string">10.0.0.1</span>&#39;, os =&gt; &#39;<span class="hljs-string">Debian 9</span>&#39; },
            { ip =&gt; &#39;<span class="hljs-string">10.0.0.2</span>&#39;, os =&gt; &#39;<span class="hljs-string">Debian 8</span>&#39; }
        ],
    );
};
app-&gt;start;
</code></pre>

<p>Now I can fetch that JSON response by starting the web application and
going to <code>/servers</code> or by using the <code>get</code> command:</p>

<pre><code>$ perl test-api.pl get /servers
[{&quot;ip&quot;:&quot;10.0.0.1&quot;,&quot;os&quot;:&quot;Debian 9&quot;},{&quot;ip&quot;:&quot;10.0.0.2&quot;,&quot;os&quot;:&quot;Debian 8&quot;}

$ perl test-api.pl daemon
Server available at http://127.0.0.1:3000
</code></pre>

<p>That&#39;s pretty easy and shows how easy Mojolicious can be to get started.
But I have dozens of routes in my application! Combined with all the
possible data and its thousands of routes. How do I make all of them
work without copy-pasting code for every single route?</p>

<p>Let&#39;s match the whole path of the route and then create a template with
the given path. Mojolicious lets us match the whole path using the <code>*</code>
placeholder in the route path. Then we can use that path to look up the
template, which we&#39;ll put in the <code>__DATA__</code> section.</p>

<pre><code class="hljs"><span class="hljs-comment"># test-api.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
any &#39;<span class="hljs-string">/*path</span>&#39; =&gt; <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        template =&gt; <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">stash</span>( &#39;<span class="hljs-string">path</span>&#39; ),
        <span class="hljs-function">format</span> =&gt; &#39;<span class="hljs-string">json</span>&#39;,
    );
};
app-&gt;start;
<span class="hljs-keyword">__DATA__</span>
@@ servers.json.ep
[
    { &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; },
    { &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;os&quot;: &quot;Debian 8&quot; }
]
</code></pre>

<p>Again, we can use the <code>get</code> command to test that we get the right data:</p>

<pre><code>$ perl test-api.pl get /servers
[
    { &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; },
    { &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;os&quot;: &quot;Debian 8&quot; }
]
</code></pre>

<p>So now I can write a bunch of JSON in my script and it will be exposed
as an API. But I&#39;d like it to be easier to make lists of things: REST
APIs often have one endpoint as a list and another as an individual item
in that list. We can make a list by composing our individual parts using
Mojolicious templates and the <code>include</code> template helper:</p>

<pre><code class="hljs"><span class="hljs-comment"># test-api.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
any &#39;<span class="hljs-string">/*path</span>&#39; =&gt; <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        template =&gt; <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">stash</span>( &#39;<span class="hljs-string">path</span>&#39; ),
        <span class="hljs-function">format</span> =&gt; &#39;<span class="hljs-string">json</span>&#39;,
    );
};
app-&gt;start;
<span class="hljs-keyword">__DATA__</span>
@@ servers.json.ep
[
    &lt;%= include &#39;servers/1&#39; %&gt;,
    &lt;%= include &#39;servers/2&#39; %&gt;
]
@@ servers/1.json.ep
{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; }
@@ servers/2.json.ep
{ &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;os&quot;: &quot;Debian 8&quot; }
</code></pre>

<p>Now I can test the list endpoint again:</p>

<pre><code>$ perl test-api.pl get /servers
[
    { &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; }
,
    { &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;os&quot;: &quot;Debian 8&quot; }
]
</code></pre>

<p>And also one of the individual item endpoints:</p>

<pre><code>$ perl test-api.pl get /servers/1
{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; }
</code></pre>

<p>Currently we handle all request methods (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>)
the same, but my API doesn&#39;t work like that. So, I need to be able to
provide different data for different request methods. To do that, let&#39;s add the
request method to the template path:</p>

<pre><code class="hljs"><span class="hljs-comment"># test-api.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
any &#39;<span class="hljs-string">/*path</span>&#39; =&gt; <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        template =&gt; <span class="hljs-function">join</span>( &#39;<span class="hljs-string">/</span>&#39;, <span class="hljs-function">uc</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">req</span>-&gt;<span class="hljs-type">method</span>, <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">stash</span>( &#39;<span class="hljs-string">path</span>&#39; ) ),
        <span class="hljs-function">format</span> =&gt; &#39;<span class="hljs-string">json</span>&#39;,
    );
};
app-&gt;start;
<span class="hljs-keyword">__DATA__</span>
@@ GET/servers.json.ep
[
    &lt;%= include &#39;get/servers/1&#39; %&gt;,
    &lt;%= include &#39;get/servers/2&#39; %&gt;
]
@@ GET/servers/1.json.ep
{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; }
@@ GET/servers/2.json.ep
{ &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;os&quot;: &quot;Debian 8&quot; }
@@ POST/servers.json.ep
{ &quot;status&quot;: &quot;success&quot;, &quot;id&quot;: 3, &quot;server&quot;: &lt;%== $c-&gt;req-&gt;body %&gt; }
</code></pre>

<p>Now all our template paths start with the HTTP request method (<code>GET</code>),
allowing us to add different routes for <code>POST</code> requests and other HTTP
methods.</p>

<p>We also added a <code>POST/servers.json.ep</code> template that shows us getting
a successful response from adding a new server via the API. It even
correctly gives us back the data we submitted, like our original API
might do.</p>

<p>We can test our added <code>POST /servers</code> method with the <code>get</code> command
again:</p>

<pre><code>$ perl test-api.pl get -M POST -c &#39;{ &quot;ip&quot;: &quot;10.0.0.3&quot; }&#39; /servers
{ &quot;status&quot;: &quot;success&quot;, &quot;id&quot;: 3, &quot;server&quot;: { &quot;ip&quot;: &quot;10.0.0.3&quot; } }
</code></pre>

<p>Now what if I want to test what happens when the API gives me an error?
Mojolicious has an easy way to layer on additional templates to use for
certain routes: <a href="http://mojolicious.org/perldoc/Mojolicious/Guides/Rendering#Template-variants">Template
variants</a>.
These variant templates will be used instead of the original template,
but only if they are available. Read more on <a href="http://preaction.me/blog/2017/12/07/day-7-using-template-variants-for-a-beta-landing-page/">how to use template
variants yesterday on the advent
calendar</a>.</p>

<p>By setting the template variant to the application &quot;mode&quot;, we can easily
switch between multiple sets of templates by adding <code>-m &lt;mode&gt;</code> to the
command we run.</p>

<pre><code class="hljs"><span class="hljs-comment"># test-api.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
any &#39;<span class="hljs-string">/*path</span>&#39; =&gt; <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        template =&gt; <span class="hljs-function">join</span>( &#39;<span class="hljs-string">/</span>&#39;, <span class="hljs-function">uc</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">req</span>-&gt;<span class="hljs-type">method</span>, <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">stash</span>( &#39;<span class="hljs-string">path</span>&#39; ) ),
        variant =&gt; <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">app</span>-&gt;<span class="hljs-type">mode</span>,
        <span class="hljs-function">format</span> =&gt; &#39;<span class="hljs-string">json</span>&#39;,
    );
};
app-&gt;start;
<span class="hljs-keyword">__DATA__</span>
@@ GET/servers.json.ep
[
    &lt;%= include &#39;get/servers/1&#39; %&gt;,
    &lt;%= include &#39;get/servers/2&#39; %&gt;
]
@@ GET/servers/1.json.ep
{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; }
@@ GET/servers/2.json.ep
{ &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;os&quot;: &quot;Debian 8&quot; }
@@ POST/servers.json.ep
{ &quot;status&quot;: &quot;success&quot;, &quot;id&quot;: 3, &quot;server&quot;: &lt;%== $c-&gt;req-&gt;body %&gt; }
@@ POST/servers.json+error.ep
% $c-&gt;res-&gt;code( 400 );
{ &quot;status&quot;: &quot;error&quot;, &quot;error&quot;: &quot;Bad request&quot; }
</code></pre>

<pre><code>$ perl test-api.pl get -m error -M POST -c &#39;{}&#39; /servers
{ &quot;status&quot;: &quot;error&quot;, &quot;error&quot;: &quot;Bad request&quot; }
</code></pre>

<p>And finally, since I&#39;m using this to test an AJAX web application,
I need to allow the preflight <code>OPTIONS</code> request to succeed and I need to
make sure that all of the correct <code>Access-Control-*</code> headers are set
to allow for cross-origin requests.</p>

<pre><code class="hljs"><span class="hljs-comment"># test-api.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
hook after_build_tx =&gt; <span class="hljs-keyword">sub </span>{
<span class="hljs-keyword">my</span> (<span class="hljs-type">$tx</span>, <span class="hljs-type">$app</span>) = <span class="hljs-type">@_</span>;
    <span class="hljs-type">$tx</span>-&gt;<span class="hljs-type">res</span>-&gt;<span class="hljs-type">headers</span>-&gt;<span class="hljs-type">header</span>( &#39;<span class="hljs-string">Access-Control-Allow-Origin</span>&#39; =&gt; &#39;<span class="hljs-string">*</span>&#39; );
    <span class="hljs-type">$tx</span>-&gt;<span class="hljs-type">res</span>-&gt;<span class="hljs-type">headers</span>-&gt;<span class="hljs-type">header</span>( &#39;<span class="hljs-string">Access-Control-Allow-Methods</span>&#39; =&gt; &#39;<span class="hljs-string">GET, POST, PUT, PATCH, DELETE, OPTIONS</span>&#39; );
    <span class="hljs-type">$tx</span>-&gt;<span class="hljs-type">res</span>-&gt;<span class="hljs-type">headers</span>-&gt;<span class="hljs-type">header</span>( &#39;<span class="hljs-string">Access-Control-Max-Age</span>&#39; =&gt; <span class="hljs-number">3600</span> );
    <span class="hljs-type">$tx</span>-&gt;<span class="hljs-type">res</span>-&gt;<span class="hljs-type">headers</span>-&gt;<span class="hljs-type">header</span>( &#39;<span class="hljs-string">Access-Control-Allow-Headers</span>&#39; =&gt; &#39;<span class="hljs-string">Content-Type, Authorization, X-Requested-With</span>&#39; );
};
any &#39;<span class="hljs-string">/*path</span>&#39; =&gt; <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-comment"># Allow preflight OPTIONS request for XmlHttpRequest to succeed</span><span class="hljs-comment">
</span>    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">rendered</span>( <span class="hljs-number">204</span> ) <span class="hljs-keyword">if</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">req</span>-&gt;<span class="hljs-type">method</span> eq &#39;<span class="hljs-string">OPTIONS</span>&#39;;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        template =&gt; <span class="hljs-function">join</span>( &#39;<span class="hljs-string">/</span>&#39;, <span class="hljs-function">uc</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">req</span>-&gt;<span class="hljs-type">method</span>, <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">stash</span>( &#39;<span class="hljs-string">path</span>&#39; ) ),
        variant =&gt; <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">app</span>-&gt;<span class="hljs-type">mode</span>,
        <span class="hljs-function">format</span> =&gt; &#39;<span class="hljs-string">json</span>&#39;,
    );
};
app-&gt;start;
<span class="hljs-keyword">__DATA__</span>
@@ GET/servers.json.ep
[
    &lt;%= include &#39;get/servers/1&#39; %&gt;,
    &lt;%= include &#39;get/servers/2&#39; %&gt;
]
@@ GET/servers/1.json.ep
{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;os&quot;: &quot;Debian 9&quot; }
@@ GET/servers/2.json.ep
{ &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;os&quot;: &quot;Debian 8&quot; }
@@ POST/servers.json.ep
{ &quot;status&quot;: &quot;success&quot;, &quot;id&quot;: 3, &quot;server&quot;: &lt;%== $c-&gt;req-&gt;body %&gt; }
@@ POST/servers.json+error.ep
% $c-&gt;res-&gt;code( 400 );
{ &quot;status&quot;: &quot;error&quot;, &quot;error&quot;: &quot;Bad request&quot; }
</code></pre>

<p>Now I have 20 lines of code that can be made to mock any JSON API
I write. Mojolicious makes everything easy!</p>

                <p><a href="http://preaction.me/draft/2017/12/04/mocking-a-rest-api-with-mojolicious/#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="http://preaction.me/draft/tag/mojolicious/">mojolicious</a>
                <a href="http://preaction.me/draft/tag/web/">web</a>
            </p>
        ]]></content>
        <updated>2017-12-04T00:00:00Z</updated>
        <category term="mojolicious" />
        <category term="web" />
    </entry>
    <entry>
        <id>http://preaction.me/draft/2017/12/04/using-template-variants-for-a-beta-landing-page/</id>
        <title>Using Template Variants For a Beta Landing Page</title>
        <link href="http://preaction.me/draft/2017/12/04/using-template-variants-for-a-beta-landing-page/" rel="alternate" />
        <content type="html"><![CDATA[
            <p><a href="http://cpantesters.org">CPAN Testers</a> is a pretty big project with a long,
storied history. At its heart is a data warehouse holding all the test reports
made by people installing CPAN modules. Around that exists an ecosystem of
tools and visualizations that use this data to provide useful insight into the
status of CPAN distributions.</p>

<p>For the <a href="http://github.com/cpan-testers/cpantesters-web">CPAN Testers webapp
project</a>, I needed a way to
show off some pre-release tools with some context about what they are and how
they might be made ready for release. I needed a &quot;beta&quot; website with a front
page that introduced the beta projects. But, I also needed the same
<a href="http://mojolicious.org">Mojolicious</a> application to serve (in the future) as a
production website. The front page of the production website would be
completely different from the front page of the beta testing website.</p>

<p>To achieve this, I used <a href="http://mojolicious.org/perldoc/Mojolicious/Guides/Rendering#Template-variants">Mojolicious&#39;s template variants
feature</a>.
First, I created a variant of my index.html template for my beta site
and called it <code>index.html+beta.ep</code>.</p>

<pre><code class="hljs"><span class="hljs-keyword">&lt;h1&gt;</span>CPAN Testers Beta<span class="hljs-keyword">&lt;/h1&gt;</span>
<span class="hljs-keyword">&lt;p&gt;</span>This site shows off some new features currently being tested.<span class="hljs-keyword">&lt;/p&gt;</span>
<span class="hljs-keyword">&lt;h2&gt;&lt;a</span> href=<span class="hljs-string">&quot;/chart.html&quot;</span><span class="hljs-keyword">&gt;</span>Release Dashboard<span class="hljs-keyword">&lt;/a&gt;&lt;/h2&gt;</span>
</code></pre>

<p>Next, I told Mojolicious to use the &quot;beta&quot; variant when in &quot;beta&quot; mode
by passing <code>$app-&gt;mode</code> to the <code>variant</code> stash variable.</p>

<pre><code class="hljs"><span class="hljs-comment"># myapp.pl</span><span class="hljs-comment">
</span><span class="hljs-keyword">use</span> <span class="hljs-function">Mojolicious::Lite</span>;
get &#39;<span class="hljs-string">/*path</span>&#39;, { path =&gt; &#39;<span class="hljs-string">index</span>&#39; }, <span class="hljs-keyword">sub </span>{
    <span class="hljs-keyword">my</span> ( <span class="hljs-type">$c</span> ) = <span class="hljs-type">@_</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">render</span>(
        template =&gt; <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">stash</span>( &#39;<span class="hljs-string">path</span>&#39; ),
        variant =&gt; <span class="hljs-type">$c</span>-&gt;<span class="hljs-type">app</span>-&gt;<span class="hljs-type">mode</span>,
    );
};
app-&gt;start;
</code></pre>

<p>The mode is set by passing the <code>-m beta</code> option to Mojolicious&#39;s <code>daemon</code> or
<code>prefork</code> command.</p>

<pre><code>$ perl myapp.pl daemon -m beta
</code></pre>

<p>This gives me the <a href="http://beta.cpantesters.org">new landing page for beta.cpantesters.org</a>.</p>

<pre><code>$ perl myapp.pl get / -m beta
&lt;h1&gt;CPAN Testers Beta&lt;/h1&gt;
&lt;p&gt;This site shows off some new features currently being tested.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;/chart.html&quot;&gt;Release Dashboard&lt;/a&gt;&lt;/h2&gt;
</code></pre>

<p>But now I also need to replace the original landing page (index.html.ep)
so it can still be seen on the beta website. I do this with a simple
trick: I created a new template called <code>web.html+beta.ep</code> that imports
the original template and unsets the <code>variant</code> stash variable. Now
I can see the <a href="http://beta.cpantesters.org/web">main index page on the beta site at
http://beta.cpantesters.org/web</a>.</p>

<pre><code class="hljs">%= include &#39;index&#39;, variant =&gt; undef
</code></pre>

<pre><code>$ perl myapp.pl get /web -m beta
&lt;h1&gt;CPAN Testers&lt;/h1&gt;
&lt;p&gt;This is the main CPAN Testers application.&lt;/p&gt;
</code></pre>

<p>Template variants are a useful feature in some edge cases, and this isn&#39;t the
first time I&#39;ve found a good use for them. I&#39;ve also used them to provide a
different layout template in &quot;development&quot; mode to display a banner saying
&quot;You&#39;re on the development site&quot;. Useful for folks who are undergoing user
acceptance testing. The best part is that if the desired variant for that
specific template is not found, Mojolicious falls back to the main template. I
built a mock JSON API application which made extensive use of this fallback
feature, but that&#39;s another blog post for another time.</p>

                <p><a href="http://preaction.me/draft/2017/12/04/using-template-variants-for-a-beta-landing-page/#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="http://preaction.me/draft/tag/mojolicious/">mojolicious</a>
                <a href="http://preaction.me/draft/tag/web/">web</a>
            </p>
        ]]></content>
        <updated>2017-12-04T00:00:00Z</updated>
        <category term="mojolicious" />
        <category term="web" />
    </entry>
</feed>

