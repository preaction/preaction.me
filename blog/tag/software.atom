<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://preaction.me/blog/tag/software/</id>
    <title>preaction</title>
    <updated>2017-12-03T00:00:00Z</updated>
    <link href="http://preaction.me/blog/tag/software.atom" rel="self" />
    <link href="http://preaction.me/blog/tag/software/" rel="alternate" />
    <generator version="0.093">Statocles</generator>
    <entry>
        <id>http://preaction.me/blog/2017/12/03/technology-never-dies/</id>
        <title>Technology Never Dies</title>
        <link href="http://preaction.me/blog/2017/12/03/technology-never-dies/" rel="alternate" />
        <content type="html"><![CDATA[
            <div>
<blockquote class="twitter-tweet" data-lang="en"><p dir="ltr" lang="en">List of things unpopular with programmers that I enjoy and
have produced valuable solutions with:<br>1) Perl<br>2) JavaScript<br>3)
C++<br>4) Excel<br>5) Java<br>6) CSS<br><br>Give it a month and I&#39;ll
have another one for the list... Popularity contests are for
small-minded people.</p>— Presistance (@preaction) <a href="https://twitter.com/preaction/status/936352187004878849?ref_src=twsrc%5Etfw">November
30, 2017</a></blockquote><script async charset="utf-8" src="https://platform.twitter.com/widgets.js"></script> 
</div>

<p><a href="https://twitter.com/preaction/status/936352187004878849">This tweet got a lot of likes and
replies</a>, so
I should expand on it a bit.  Most of the replies were additions to the
list: Visual Basic (tool for automating and scripting Windows),
Microsoft Access (great for small databases), PHP (which unseated Perl
as the powerhouse of the web). But some of the replies were the things
I deal with a lot: Explanations why my choices suck and I should choose
other things.</p>

<p>I&#39;m mature, experienced, and confident enough so that now those comments
don&#39;t bother me, but it&#39;s a problem for novices in the tech community.
Learning is difficult and frustrating, and hearing that the effort taken
to learn a technology is worthless because that technology is &quot;bad&quot; is
demoralizing and can lead to people leaving tech altogether.</p>

<p>So, let me help you cut off some of these discussions:</p>

<h2>X is Dead</h2>

<ul>
<li>X is obsolete</li>
<li>X is outdated</li>
<li>X is dying</li>
<li>X is dead</li>
</ul>

<p>No, it isn&#39;t. Technologies don&#39;t die easily, and I can assure you that
once a technology has left the technology journalism circuit it will
continue still for quite some time.</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Fortran">FORTRAN</a>, one of the oldest computer languages, still has new
projects being written in it, and indeed had a <a href="https://en.wikipedia.org/wiki/Fortran#Fortran_2008">new specification come
out in 2008</a> which adds concurrency and a <a href="https://en.wikipedia.org/wiki/Fortran#Fortran_2018">new spec being planned
for 2018</a>.</li>
<li>New games are being written for the
<a href="https://www.theverge.com/2017/5/9/15584416/new-games-retro-consoles-nes-snes-sega-genesis-famicom">NES</a>, <a href="https://www.theverge.com/2012/11/26/3693208/c64-indie-games-paul-koller">Commodore 64</a>, and
<a href="https://atariage.com">Atari 2600</a>.</li>
<li>Flash is still ubiquitous, despite being <a href="https://en.wikipedia.org/wiki/IPhone_(1st_generation)">declared dead in
2007</a>.</li>
<li>Operating systems abandoned by their parent companies (or whose parent
companies are dead) still have devoted communities, and even active
development (BeOS is now <a href="https://www.haiku-os.org">Haiku</a>, Solaris
has <a href="https://wiki.illumos.org/display/illumos/illumos+Home">Illumos</a>,
and even Windows XP has <a href="https://reactos.org">ReactOS</a>).</li>
</ul>

<p>What they might mean is &quot;X is no longer a way to be successful&quot;, which is also
mostly false depending on how you measure success: If you want to make VC
money, that is probably true. If you want to learn about technology or solve
problems using technology, it is entirely false. If you want to make a career
in technology, it&#39;s certainly false: Even old technology needs support,
maintenance, and development.</p>

<p>What they might also mean is &quot;X is no longer the only technology that can solve
its specific problem&quot;, and that&#39;s a good thing. Technology evolves when it is
exposed to new ideas, and there&#39;s no better way to get exposed to new ideas
than to compete with other technology. This is why FORTRAN has a new spec
coming out, as well as languages like Ada and COBOL.</p>

<p>&quot;X is dead&quot; is anti-marketing. Don&#39;t be taken in.</p>

<h2>X is Bad</h2>

<ul>
<li>X is ugly</li>
<li>X is unmaintainable</li>
<li>X is terrible</li>
<li>X considered harmful</li>
<li>X is bad</li>
</ul>

<p>Technology is invented at a specific time for a specific purpose. There aren&#39;t
many technologies that gain widespread acceptance while being unsuitable for
their purposes. So, how can that surviving technology be entirely bad?</p>

<p>What they almost always mean is &quot;X is bad to use now&quot;, and that&#39;s also often
false: While there may be more and better solutions to the particular problem
(which, as explained above, is a good thing), a surviving technology often
still has niches where it fits better than any other. This does mean that you
need to do your research: Look at the problem domain, find the solutions, and
if you have time, try them out to see which one you like better. Don&#39;t let &quot;X
is bad&quot; stop you from trying X out to see if it solves your problem.</p>

<p>What they may also mean is &quot;X teaches bad things&quot;, which is vehemently false:
Learning about the history of a technology is important. Learning about
historical problems and solutions is important. Technology is built for a
reason. Learning those reasons will explain the design decisions made. Learning
about design decisions and tradeoffs can teach you how to proceed when nothing
is a good option. No technology is built to be deliberately terrible (though
some technologies are certainly satirical or farcical, they are excellent
satire/farce and should be evaluated as such, like INTERCAL).</p>

<p>I have, in fact, learned the most from learning other languages designs.
Java taught me a lot about OO, which I brought in to all my programs.
Using pthreads in C++ taught me a lot about process safety and
message-passing, which I then started using <a href="http://zeromq.org">Zeromq</a>
to solve for me (when I can, but I still know how to solve that problem
without if needed). The more shell scripting I learn, the less work
I end up having to do (fact). Shell taught me fantastic lessons about
composability of programs that I never thought possible, and I’ve got
some projects that take full advantage of that.</p>

<p>&quot;X is bad&quot; is almost always a disingenuous attempt to get you to use their
favorite technology. Don&#39;t be fooled!</p>

<p>Technology is not a popularity contest. Technology is not good because it&#39;s
popular, and it&#39;s not bad because it is unpopular. Technology is not good
because its unique, and it&#39;s not bad because it exists in a crowded maze of
solutions, all alike. We need to evaluate technology objectively and
critically, whether popular or unpopular. And we must always remember to be
kind to people using technology.</p>

                <p><a href="http://preaction.me/blog/2017/12/03/technology-never-dies/#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="http://preaction.me/blog/tag/software/">software</a>
                <a href="http://preaction.me/blog/tag/community/">community</a>
            </p>
        ]]></content>
        <updated>2017-12-03T00:00:00Z</updated>
        <category term="software" />
        <category term="community" />
    </entry>
    <entry>
        <id>http://preaction.me/blog/2015/03/08/consuming-chaos/</id>
        <title>Consuming Chaos</title>
        <link href="http://preaction.me/blog/2015/03/08/consuming-chaos/" rel="alternate" />
        <content type="html"><![CDATA[
            <p><img class="u-pull-left" src="http://preaction.me/images/blog/chaos.jpg" style="width: 40%"></p>

<p>For what seems hours, you scan the board. The colors are sharp against the
simple background. Some movement catches your eye, but it doesn&#39;t feel right,
so you ignore it. Time stretches on.</p>

<p>There! The perfect move. Leaving the perfect next move. A quick flick. A match.
The pieces fall into place. Another match. Another. Another. A special piece.
Another special piece. It fires, triggering more. Chaos consumes.</p>

<p>The board is in ruins. Your carefully planned next move is lost in the
destruction. You&#39;re back to scanning the board to try to find where you belong
in this new world.</p>

<p>Is this a game, or is it your development strategy?</p>

<p>Software development is chaos. Either you work to managing chaos, consuming it,
or it works on consuming you. There are too many possibilities, too much input,
to brute-force your way to completion (how much software do you know of that
can be considered complete?).</p>

<p>In the face of these possibilities, a rigid development plan will fail. Vague
goals are better. Goals written in terms of a problem are best. Problems don&#39;t
change, once you find their roots.</p>

<p>I didn&#39;t know this post was going to be about Agile, but there it is.</p>

<p>Exact is for computers. We are not computers. We are human. We are chaos.</p>

                <p><a href="http://preaction.me/blog/2015/03/08/consuming-chaos/#section-2">Continue reading...</a></p>
            <p>Tags:
                <a href="http://preaction.me/blog/tag/software/">software</a>
            </p>
        ]]></content>
        <updated>2015-03-08T00:00:00Z</updated>
        <category term="software" />
    </entry>
    <entry>
        <id>http://preaction.me/blog/2014/12/23/leaving-crumb-trails-talking-to-myself.html</id>
        <title>Leaving Crumb Trails -- Talking to Myself</title>
        <author><name>preaction</name></author>
        <link href="http://preaction.me/blog/2014/12/23/leaving-crumb-trails-talking-to-myself.html" rel="alternate" />
        <content type="html"><![CDATA[
            <p>The past me is another person. Sometimes antagonist, sometimes friend, past me
(postaction?) had ideas, hopes, and dreams and developed some of them into
software that I and others use. Unfortunately, that asshole left bugs all
through the code for me to fix.</p>

<p>I can&#39;t blame him. Nobody&#39;s perfect, not even idealized/demonized copies of my
past self. But I do have to fix them, and deal with the messes he left.</p>

<p>Lucky for me, while he was writing buggy software, he left extensive notes for
me to use...</p>

                <ul>
                    <li><a href="http://blogs.perl.org/users/preaction/2014/12/leaving-crumb-trails----talking-to-myself.html">
                        Continue reading <em>Leaving Crumb Trails -- Talking to Myself</em> on blogs.perl.org...
                    </a></li>
                    <li><a href="http://preaction.me/blog/2014/12/23/leaving-crumb-trails-talking-to-myself.html#section-2">
                        Continue reading on preaction
                    </a></li>
                </ul>
            <p>Tags:
                <a href="http://preaction.me/blog/tag/software/">software</a>
            </p>
        ]]></content>
        <updated>2014-12-23T00:00:00Z</updated>
        <category term="software" />
    </entry>
    <entry>
        <id>http://preaction.me/blog/2012/11/04/testing-is-a-feature-of-your-service.html</id>
        <title>Testing is a Feature of Your Service</title>
        <author><name>preaction</name></author>
        <link href="http://preaction.me/blog/2012/11/04/testing-is-a-feature-of-your-service.html" rel="alternate" />
        <content type="html"><![CDATA[
            <p>My job at Bank of America consists largely of data collection and storage. To
collect data in Perl, I have to write XS modules to interface with the
vendor-supplied native libraries. Because I want to know my code works, my XS
modules come with robust test suites, testing that everything works correctly.</p>

<p>Since the XS module was intended to be used by other, larger systems, I decided
to help those larger systems test their dependency on my module: I included a
<a href="http://search.cpan.org/perldoc?Test::MockObject">Test::MockObject</a> that mocked
my module&#39;s interface. By using my test module, the tests can try some data and
see if their code works.</p>

<p>But the hardest part to test is always the failures. How do they test if the
news service goes down in the middle of a data pull? How about if it goes down
between data pulls but still inside the same process? How do they test if the
user has input an invalid ID for data?</p>

                <ul>
                    <li><a href="http://blogs.perl.org/users/preaction/2012/11/testing-is-a-feature-of-your-service.html">
                        Continue reading <em>Testing is a Feature of Your Service</em> on blogs.perl.org...
                    </a></li>
                    <li><a href="http://preaction.me/blog/2012/11/04/testing-is-a-feature-of-your-service.html#section-2">
                        Continue reading on preaction
                    </a></li>
                </ul>
            <p>Tags:
                <a href="http://preaction.me/blog/tag/software/">software</a>
            </p>
        ]]></content>
        <updated>2012-11-04T00:00:00Z</updated>
        <category term="software" />
    </entry>
    <entry>
        <id>http://preaction.me/blog/2012/09/23/plan-software-to-live-forever.html</id>
        <title>Chicago.PM - Beyond grep - Expanding the Programmer Toolset</title>
        <author><name>preaction</name></author>
        <link href="http://preaction.me/blog/2012/09/23/plan-software-to-live-forever.html" rel="alternate" />
        <content type="html"><![CDATA[
            <p>How often have I told myself, &quot;I&#39;ll kludge this now and rewrite it later&quot;? And
how many times did I actually go back and rewrite that kludgy bit? &quot;Too often&quot;
and &quot;not enough&quot;. Many job postings include the phrase &quot;update legacy
applications,&quot; as a euphemism for &quot;rewrite poorly-designed spaghetti.&quot; The Y2K
problem was a huge exercise in code out-living the developer&#39;s plan, with a
healthy dose of cargo-culting thrown in. Lately, I&#39;ve been learning to plan for
a likely possibility: My code will survive to haunt my bug lists and my resume
for a long time.</p>

                <ul>
                    <li><a href="http://blogs.perl.org/users/preaction/2012/09/plan-software-to-live-forever.html">
                        Continue reading <em>Chicago.PM - Beyond grep - Expanding the Programmer Toolset</em> on blogs.perl.org...
                    </a></li>
                    <li><a href="http://preaction.me/blog/2012/09/23/plan-software-to-live-forever.html#section-2">
                        Continue reading on preaction
                    </a></li>
                </ul>
            <p>Tags:
                <a href="http://preaction.me/blog/tag/software/">software</a>
            </p>
        ]]></content>
        <updated>2012-09-23T00:00:00Z</updated>
        <category term="software" />
    </entry>
</feed>

